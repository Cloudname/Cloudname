package org.cloudname.idgen;

import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Logger;
import java.util.List;
import java.util.Set;
import java.util.HashSet;

import org.junit.*;
import static org.junit.Assert.*;

/**
 * Unit tests for IdGenerator.
 *
 * @author borud.
 */
public class IdGeneratorTest {
    private static final Logger log = Logger.getLogger(IdGeneratorTest.class.getName());

    @Test
    public void testSimple() throws Exception {
        IdGenerator idgen = new IdGenerator(0L);
        long id = idgen.getNextId();
        assertTrue(id != 0);
        assertNotNull(idgen.getNextIdHex());
    }

    @Test (timeout=500)
    public void testMicroBenchmark() {
        IdGenerator idgen = new IdGenerator(0L);
        int numIterations = 10000;
        long start = System.currentTimeMillis();
        for (int i = 0; i < numIterations; ++i) {
            idgen.getNextId();
        }
        long duration = System.currentTimeMillis() - start;
        log.info("Microbenchmark: iterations = " + numIterations + ", time = " + duration + "ms");
    }

    /**
     * Test that we can cope with a clock that sometimes jumps 10ms
     * backwards in time.  Also ensure that the IDs generated are
     * unique.
     */
    @Test
    public void testBackwardsClock() {
        int numIterations = 10000;
        Set<Long> idSet = new HashSet<Long>(numIterations);

        // Time provider which jumps 5ms back in time every 109 calls.
        TimeProvider tp = new TimeProvider() {
                private int counter = 0;
                @Override
                public long getTimeInMillis() {
                    if ((counter++ % 109) == 0) {
                        return System.currentTimeMillis() - 5;
                    }
                    return System.currentTimeMillis();
                }
            };

        IdGenerator idgen = new IdGenerator(0L, tp);
        for (int i = 0; i < numIterations; ++i) {
            assertTrue(idSet.add(idgen.getNextId()));
        }
        assertEquals(numIterations, idSet.size());
    }

    /**
     * Use invalid parameters for the id generator - too many bits
     */
    @Test (expected = IllegalArgumentException.class)
    public void testMaxNumberOfBits() {
        new IdGenerator(0, 32, 32);
    }

    /**
     * Use invalid parameters for the id generator - too few worker bits
     */
    @Test (expected = IllegalArgumentException.class)
    public void testSmallWorkerId() {
        new IdGenerator(128, 1, 31);
    }

    /**
     * Test array of generators - ensure that the worker id results in unique ids
     */
    @Test public void testMultiBits() {
        final int sequenceBits = 8;
        final int workerBits = 14;

        // Create an array of 10 workers, each with an unique ID
        final IdGenerator workers[] = new IdGenerator[10];
        for (int i = 0; i < workers.length; i++) {
            workers[i] = new IdGenerator(i * 100, workerBits, sequenceBits);
        }

        final Set<Long> ids = new HashSet<Long>();

        // Let each worker create a lot of IDs (more than can fit in a single sequence)
        for (long i = 0; i < (long) (Math.pow(2, sequenceBits) * 10); i++) {
            for (int j = 0; j < workers.length; j++) {
                long id = workers[j].getNextId();
                if (ids.contains(id)) {
                    fail(id + " is already generated by the IdGenerator");
                }
                ids.add(workers[j].getNextId());
            }
        }
    }

    /**
     * Run a simple multithreading test for the id generator; make one instance
     * and access it from multiple threads.
     */
    @Test public void testMultithreadGenerator() {
        final int numSequenceBits = 12;
        final int numWorkerBits = 12;

        final IdGenerator worker = new IdGenerator(1, numWorkerBits, numSequenceBits);

        final int numThreads = 10;
        final int numRunnables = 20;
        final int numLoops = (int) (Math.pow(2, numSequenceBits) * 10);

        // Create hash set for all outputs
        final List<long[]> ids = new ArrayList<long[]>();

        for (int i = 0; i < numRunnables; i++) {
            ids.add(new long[numLoops]);
        }

        final CountDownLatch startLatch = new CountDownLatch(numThreads);
        final CountDownLatch doneLatch = new CountDownLatch(numRunnables);

        ExecutorService executor = Executors.newFixedThreadPool(numThreads);

        for (int i = 0; i < numRunnables; i++) {
            final long[] loopData = ids.get(i);

            Runnable r = new Runnable() {
                public void run() {
                    startLatch.countDown();
                    try {
                        startLatch.await();
                    } catch (InterruptedException ie) {
                        throw new RuntimeException(ie);
                    }

                    for (int j = 0; j < numLoops; j++) {
                        loopData[j] = worker.getNextId();
                    }
                    doneLatch.countDown();
                }
            };
            executor.execute(r);
        }

        try {
            doneLatch.await();
        } catch (InterruptedException ie) {
            throw new RuntimeException(ie);
        }
        executor.shutdown();

        Set<Long> allids = new HashSet<Long>();

        // now compare the outputs. should not contain duplicates
        for (int i = 0; i < ids.size(); i++) {
            // compare to first element
            for (Long id : ids.get(i)) {
                assertFalse("index [" + i + "] not set earlier ("
                        + id.longValue() + ")", allids.contains(id.longValue()));
                allids.add(id.longValue());
            }
        }
    }

    /**
     * using a custom worker ID yields different IDs
     */
    @Test public void testCustomWorkerId() {
        IdGenerator worker100 = new IdGenerator(100);

        IdGenerator worker200 = new IdGenerator(200);

        assertTrue("Different worker id yields different id",
                worker100.getNextId() != worker200.getNextId());
    }

}
